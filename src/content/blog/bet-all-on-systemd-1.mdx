---
title: "systemdに全部賭けろ（第一部）"
date: 2025-08-06
lastmod: 2025-08-23
description: "Linuxでルータを作る（フレッツ光 + v6プラス、下流にホームゲートウェイあり）"
tags: ["bet-all-on-systemd", "tech", "network", "linux"]
emoji: "⚡"
order: 1
---

![ルータの稼働状況](../../assets/image/systemd-router-btm.png)

## まえがき

[systemd](https://systemd.io/)が森羅万象を統べるようになって千年ほどが経った。

ダイソン球の姿勢制御から、マスドライバーの運行管理まで、あらゆるプロセスがかれの傘下に入った。政治（`systemd-politicsd`）、経済（`systemd-economyd`）、文化（`systemd-cultured`）など、名だたるサブシステムが**デーモン**に置き換えられ、社会構造は大きく改変されていった。ときには抵抗もあったが、systemdが「**PID 1**」と叫べば、ひれ伏さぬものはなかった。

そのように強力であるため、systemdは**ご家庭のルータになる**こともできる（ここからは本当）。そこで、この記事では[systemd-networkd](https://www.freedesktop.org/software/systemd/man/latest/systemd-networkd.html)を使い、Linuxルータを作る。最終的には、

- フレッツ光（IPv6 IPoE）+ v6プラス（IPv4 over IPv6 / MAP-E）に接続し
- 下流にNTTの[\{ホームゲートウェイ|HGW}](https://web116.jp/ced/personal/hgw/)を置いてひかり電話を使う

環境を実現する。

***

<details>
  <summary>記事の構成について</summary>

  記事は三部に分かれている。

  - [第一部：環境構築](./bet-all-on-systemd-1) :arrow\_left: 今回
  - [第二部：基本機能構築](./bet-all-on-systemd-2)
  - [第三部：HGW設置](./bet-all-on-systemd-3)

  第一部では、ネットワーク構成とルータの環境構築について扱う。
</details>

***

## 背景

とはいえ、なぜそもそもこんな手間が必要なのだろうか？　背景を補足しておこう。

### なぜ自前ルータ？

すでにあちこちで書かれているように、フレッツ光の回線に[ひかり電話オプション](https://flets.com/hikaridenwa/)が付くと、**/56**のIPv6プレフィックスが払い出される。このとき、同時に貸し出されるHGWは以下のような挙動をする。

- HGWをルータとして使う場合：/56のうち、**/64**のプレフィックスがSLAACで配られる
- HGWの下流に自前ルータを置く場合：/56のうち、**/60**のプレフィックスがDHCPv6-PDで自前ルータに払い出される

つまり残念なことに、与えられたアドレス空間の$1/256$ないし$1/16$しか有効に使われない[^1]。

[^1]: もちろん、これでもアドレス数は十分なのだが、せっかく与えられたものが無駄になるのは気に入らない

そのほかにも、HGWを上流に置くことの弊害はいろいろある（性能の限界、自由度の低さなど）。そこで代わりに自前のルータを上流に置きたい、という欲が出てくる。

### なぜLinux？

ところがひかり電話を使う場合、何も考えずHGWを取り外すことはできない。というのも、HGWはひかり電話ルータでもあり、まともに機能するには以下の二つが必要だからだ。

- DHCPv4でフレッツ網から**グローバルIPv4アドレス**（/30）を受け取ること
- DHCPv6オプション（**ひかり電話関連情報**）を受け取ること

この制約に対し、二つほど解決策がある。

#### 方法1: 選手交代

一つ目は、単純に自前の市販ルータでHGWを置き換えてしまえ、というものだ。これは[NTTお墨付き](https://flets.com/hikaridenwa/use/uniport.html)の方法だが、いくつかデメリットもある。

1. ひかり電話対応ルータしか使えない
   - NVR500、NVR510、NVR700Wなど
2. HGW特有の機能（例：SIPサーバ機能）を捨てることになる
3. そこまで自由度は増えない
4. ~~優等生すぎて面白くない~~

#### 方法2: IPv4ブリッジ

もうひとつは、IPv4を**選択的にブリッジする**という方法だ。これについては下の記事が詳しい。

[https://qiita.com/takonasu/items/7a6cc05e4037dfb4d1a1](https://qiita.com/takonasu/items/7a6cc05e4037dfb4d1a1)

ざっくりいえば、`フレッツ網-ルータ-HGW`のように接続し、ルータで

- HGW発着の
  - IPv4をブリッジし
  - IPv6をルーティングし
- ひかり電話関連情報を**別途**手に入れて、HGWに配る

という構成である。これはかなりうまく動く一方で、まだ以下の難点を残している。

1. IPv4ブリッジに対応したルータしか使えない[^2]
   - e.g. UNIVERGE IXシリーズ
2. 別途DHCPv6サーバが必要
3. 別途外部からパケットキャプチャが必要

[^2]: とはいえIPv4のブリッジ程度であれば、他社のルータでも実現できるかもしれない

特に 2. と 3. は重要で、結局のところ市販ルータが扱えるDHCPv6オプションは少ないため、別途パケットをキャプチャしたり、DHCPv6サーバを立てたりする必要がある[^3]。

[^3]: 詳しくは第三部で述べるが、DHCPv6リクエストに適切なオプション（Option 16, Vendor Class）を含めれば、ルータで直接ひかり電話関連情報を受信できる。しかしこれに対応した市販ルータは（おそらく）少ないし、よしんば受信できても、その情報を下流に送信できない

しかしLinuxでルータを作れば、これらすべて──IPv4のブリッジ、DHCPv6サーバ、DHCPv6オプションの受信──を一台で担える。そのうえ適当な端末（たとえばミニPC）さえあれば済む。ちょっとしたDIYで、シンプルかつ多機能な構成を実現できるのだ。

## 環境

参考のため、使用した回線・機器などを記しておく。

### 回線契約

- フレッツ光ネクスト相当の契約（光コラボ）
  - IPv6 IPoE
  - ひかり電話オプション付き（HGWの貸与あり、DHCPv6-PD）
  - VDSL方式（モデムの貸与あり）[^4]
- v6プラス
  - IPv4 over IPv6（MAP-E方式）
  - 固定（≒専有）IPではない
  - [フレッツ・ジョイント](https://www.ntt-west.co.jp/news/1304/130418a.html)を利用

事情あってVDSLだが、それ以外はごく一般的な契約内容になっている。

以下では例示のため、プロバイダから割り振られたIPv6プレフィックスを`3fff:0:0:ab00::/56`とする。IPv4 over IPv6の接続に必要な情報は、あらかじめプロバイダから得るか、さもなくば[計算機](https://ipv4.web.fc2.com/map-e.html)などで算出しておく。ここでは下表のように仮定する。

| 項目                    | 値                     |
| :-------------------- | :-------------------- |
| CE                    | `3fff:0:0:ab00::ce`   |
| IPv4アドレス              | `192.0.2.1`           |
| PS（= ポートセット）ID        | `171`（10進）/ `ab`（16進） |
| option peeraddr（= BR） | `2001:db8::1/64`      |

[^4]: この記事では、VDSLモデム（ないしONU）とHGWが独立していることを暗黙の前提としている。両者が一体化しているHGWの場合、いわゆる「UNI出し」をするとこの状態にできる。小型ONUの場合は、Linuxルータに別途SFP+ポートが必要になる

### 機器

| 項目      | 機種                                                                                                 | 用途・備考                                                                                      |
| :------ | :------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------- |
| ミニPC    | （某社のミニPC）                                                                                          | ルータ用。LANポートが二つ以上あればよい[^5]。                                                                 |
| L2スイッチ  | TP-Link [TL-SG105PE](https://www.tp-link.com/jp/business-networking/easy-smart-switch/tl-sg105pe/) | ポート数を増やすために必要。タグVLAN（802.1Q）が切れればよい                                                        |
| HGW     | 沖電気 [RX-600KI](https://web116.jp/shop/hikari_r/600ki/600ki_00.html)                                | ひかり電話ルータ                                                                                   |
| VDSLモデム | 住友電工 VH100-4ES                                                                                     | [FTTH](https://ja.wikipedia.org/wiki/FTTH)回線であれば、単独型ONU、もしくは「UNI出し」したHGWの下半分（ONU部分）がこれにあたる |

[^5]: VLANを駆使すれば、ポートが一つでもなんとかなるかもしれない

ルータ用の機材には、適当なミニPCを用意した。ミニPCだけではポート数が足りないため、タグVLANに対応したL2スイッチで補った。

## ネットワーク設計

今回自作ルータが担う役割を整理しておこう。

1. 基本的なルータの機能
   - **DHCPv6クライアントを動かし**、フレッツ網からIPv6プレフィックスを受け取る
     - **同時に、ひかり電話関連情報（DHCPv6オプション）も受け取る**
   - **IPv4 over IPv6（MAP-E）のトンネルを張る**
   - 宅内機器側のセグメントを作り、IPv6・IPv4を配る
   - その他、ファイアウォールなど
2. ひかり電話ルータ（HGW）の世話
   - HGW側のセグメントを分離する
   - **フレッツ網-HGW間のIPv4パケットをブリッジする**
   - DHCPv6-PDサーバを動かし、HGW向けにフレッツ網に似たIPv6環境を整える
     - IPv6プレフィックスの一部をHGWに再委譲する
     - **ひかり電話関連情報をHGWに配布する**

このうち太字の項目に関連して、いくつか考慮すべき点がある。

### IPv4パケットのブリッジについて

ブリッジデバイスを使ってもよいが、nftablesの[fwd文](https://www.netfilter.org/projects/nftables/manpage.html#:~:text=FWD%20STATEMENT)が便利だ。入ってくる生のパケットをそのまま別のインターフェースに転送できるので、実質L2スイッチのように振る舞ってくれる。

### MAP-Eのポート振り分けについて

MAP-Eに関しては、以下の記事が注目に値する。

[https://turgenev.hatenablog.com/entry/2024/04/23/031222](https://turgenev.hatenablog.com/entry/2024/04/23/031222)

執筆時点では、この記事に示されているような`tc`を使ったポート振り分けの実用例はインターネット上に見つからなかった。今回はこの方法を実環境で試してみる。

### ひかり電話関連情報の取得・配布について

ひかり電話関連情報の扱いは意外に難しい。

理想としては、フレッツ網から受け取ったDHCPv6オプションをそのままHGWに「中継」できればよいが、これができるソフトウェアはいまのところない。そこで代わりに、**DHCPv6のリースを受けるたびに、リース内容をもとにDHCPv6サーバの設定を更新する**仕組みを作る。

鍵となるのは、systemd-networkdの[D-Bus API](https://www.freedesktop.org/software/systemd/man/latest/org.freedesktop.network1.html)と、Kea（DHCPv6サーバ）の[Management API](https://kea.readthedocs.io/en/stable/arm/ctrl-channel.html)だ。systemd-networkdは、リースを受けるたびにD-Busシグナルを飛ばしてくれるうえ、リースの内容自体もD-Busで取得できる。一方、KeaのManagement APIを使うと、HTTPで動的に設定を投入できる。両者を合わせると[^6]、以下のような処理が可能になる。

[^6]: systemd-networkdには[DHCPv6サーバ機能がない](https://github.com/systemd/systemd/issues/16039)ため、併用が必要

1. DHCPv6リースを受けた際のD-Busシグナルを検知
2. D-Busを叩き、リース情報を取得
3. リース情報を元に、KeaのAPIを叩いて設定を更新

この処理を適当な言語[^7]で実装[^8]すれば、仮に将来フレッツ網から降ってくる情報が変わっても対応できる。

[^7]: なお、実装はPythonで行った。こんな処理をわざわざコンパイルするのも気が引けるし、かといってシェルスクリプトには荷が重いからだ

[^8]: D-Busとのやり取りには、[python-sdbus](https://github.com/python-sdbus/python-sdbus)というライブラリを使った

## ネットワーク構成

以上を実際の接続に落とし込み、以下の図のようになった。

### 物理接続

```d2 alt="物理接続"
direction: right
classes: {
  rj11: {
    style.stroke: gray
  }
}

vars: {
  d2-config: {
    layout-engine: elk
  }
}

**.style.font-size: 30
(** -- **)[*].style: {
  font-size: 30
  stroke-width: 5
}

ntt: NTT局舎 {
  shape: cloud
}

mdf: 共用部 {
  onu: ONU {
    style.3d: true
  }
}

ntt -- mdf.onu
home.vdsl-modem -- mdf.onu: {class: rj11}

home: 自宅 {
  vdsl-modem: VDSLモデム {
    style.3d: true
  }

  router: ルータ {
    style.3d: true
    wan0
    lan0
  }
  
  switch: スイッチ {
    style.3d: true
    p1: ポート1
    p2: ポート2
    p3: ポート3
    p4: ポート4
    p5: ポート5
  }
  
  PC: { style.3d: true }
  AP1: 無線AP1 { style.3d: true }
  AP2: 無線AP2 { style.3d: true }
  HGW: { style.3d: true }
  phone: 電話機 { style.3d: true }
  
  router.wan0 -- vdsl-modem
  router.lan0 -- switch.p1
  switch.p2 -- PC 
  switch.p3 -- AP1
  switch.p4 -- AP2
  switch.p5 -- HGW
  phone -- HGW: {class: rj11}
}

```

（青色は光ファイバー・LANケーブル、灰色は電話線）

### 論理接続

```d2 alt="論理接続"
vars: {
  d2-config: {
    layout-engine: elk
  }
}

**.style.font-size: 72
(** -- **)[*].style: {
  font-size: 72
  stroke-width: 12
}
(** <-> **)[*].style: {
  font-size: 72
  stroke-width: 12
}

classes: {
  ipv6: {
    style.stroke: "#202225"
  }
  ipv4: {
    style.stroke: "#ea3c65"
  }
  ipv4-hgw: {
    style.stroke: "#6aa2f5"
  }
}

internet: インターネット {
  v6: v6 {
    shape: cloud
  }
  
  v4: v4 {
    shape: cloud
  }
}

ngn: フレッツ網 {
  dhcpv6-server: DHCPv6サーバ {
    style.3d: true
  }
  dhcp-server: DHCPv4サーバ {
    style.3d: true
  }
  sntp-server: SNTPサーバ {
    style.3d: true
  }
  sip-server: SIPサーバ {
    style.3d: true
  }
}

vne: VNE（JPIX） {
  label.near: top-left
  br: BR {
    style.3d: true
    BR: {
      shape: sql_table
      BRアドレス: 2001:db8::1/64
    }
  }
}

router: ルータ {
  label.near: top-left
  style.3d: true
  mape0: {
    shape: sql_table
    IPv4: 192.0.2.1/32
  }
  wan0: {
    shape: sql_table
    委譲プレフィックス: 3fff:0:0:ab00::/56
    割当サブネット (v6): 3fff:0:0:ab00::/64
    CEアドレス: 3fff:0:0:ab00::ce/64
  }
  lan0: {
    home: {
      shape: sql_table
      VLAN ID: 10
      割当サブネット (v6): 3fff:0:0:ab01::/64
      割当サブネット (v4): 10.0.0.0/24
    }
    hgw: {
      shape: sql_table
      VLAN ID: 100
    }
  }
}

switch: スイッチ {
  label.near: top-left
  style.3d: true
  trunk: トランクポート {
    p1: ポート1
  }
  vlan-home: VLAN 10 {
    p2: ポート2
    p3: ポート3
    p4: ポート4
  }
  vlan-hgw: VLAN 100 {
    p5: ポート5
  }
}

home-devices: 宅内機器群 {
  PC
  無線AP
}

HGW: {
  style.3d: true
  wan: WAN側ポート {
    shape: sql_table
    委譲プレフィックス: 3fff:0:0:abf0::/60
    IPv4アドレス: (DHCP)
  }
}

ngn -- vne -- internet.v6 {class: ipv6}
vne -- internet.v4: {class: ipv4}

ngn -- router.wan0: DHCPv6-PD\n(/56) {class: ipv6}
ngn -- router.wan0: DHCPv4\n(/30) {class: ipv4-hgw}

router.wan0 -- vne.br: IPv4 over IPv6\nトンネル {class: ipv4; style.stroke-dash: 3}
router.wan0 <-> router.mape0: カプセル処理 {class: ipv4; style.stroke-dash: 3}
router.mape0 -- router.lan0.home: NAT +\nポート変換（tc） {class: ipv4}
router.lan0.home -- switch.trunk: DHCPv4 (/24)  {class: ipv4}
switch.trunk -- switch.vlan-home -- home-devices: {class: ipv4}
router.wan0 -- router.lan0.home {class: ipv6}
router.lan0.home -- switch.trunk: SLAAC + RDNSS {class: ipv6}
switch.trunk -- switch.vlan-home -- home-devices {class: ipv6}
router.wan0 -- router.lan0.hgw {class: ipv6}
router.lan0.hgw -- switch.trunk: DHCPv6-PD\n(/60) {class: ipv6}
switch.trunk -- switch.vlan-hgw -- HGW {class: ipv6}
router.wan0 -- router.lan0.hgw: 転送（L2） {class: ipv4-hgw; style.stroke-dash: 3}
router.lan0.hgw -- switch.trunk -- switch.vlan-hgw -- HGW: {class: ipv4-hgw}

HGW -- 電話機: 電話線 {style.stroke: gray}
```

（黒色はIPv6 IPoE接続、赤色はIPv4 over IPv6接続、水色はHGW専用のIPv4接続）

### 補足

ルータの物理インターフェースは以下の2つ。

- `wan0`（MAC: `de:ad:be:ef:00:01`）
- `lan0`（MAC: `de:ad:be:ef:00:02`）

これに加えて、仮想インターフェースとして以下の3つを作成する。

- `mape0@wan0`：IPv4 over IPv6のトンネルデバイス
- `home@lan0`：VLAN用サブインターフェース（ID = 10）
  - 宅内機器側セグメントのデフォルトゲートウェイ
- `hgw@lan0`：VLAN用サブインターフェース（ID = 100）
  - HGW側セグメントのデフォルトゲートウェイ（IPv6のみ）

L2スイッチ側でも、これに対応したタグVLAN（ID = 10, 100）を設定する[^9]。

[^9]: なお、もう一つVLANを切ってHGWの**LAN側**と接続しておくと、ルータ経由でHGWのWeb設定画面にアクセスできて便利だが、今回は省略した

## 手順1：環境構築

### 免責

手元では、以下の構成は安定して動作しており、実用上も問題は出ていない。しかしあくまでも事業者の想定していない構成であることは留意ねがいたい。動作は保証できないし、この記事の内容を実践した結果としていかなる損害が生じても、私は一切責任を負わない。

### #ArchLinuxInstallBattle

\{まず、ミニPCにArch Linuxをインストールする|I use Arch, BTW}。

使用するLinuxディストリビューションは自由だが、systemd-networkdを使う都合上、systemdのバージョンが新しいほうがおそらく良い。

解説記事が無数にあるため、詳細なインストールプロセスは省略する。なお、意味があるかはわからないが、カーネルには`linux-rt`を使った。

この段階で、後で必要になるソフトウェアもインストールしておく。

```sh
pacman -S ethtool nftables iptables-nft ndisc6 kea jq
paru -S python-sdbus
```

### NICのチューニング

続いてNICのチューニングをする（このあたりは使う機材による）。

今回使った機材には、RTL8125BというRealtek :crab: の2.5GbE NICが載っていた。しかし初期状態では汎用のドライバ（`r8169`）で動いており、本来の機能を発揮できない。そこで製造元から配られている専用ドライバをインストールする。Arch Linuxの場合、[AURにあるパッケージ](https://aur.archlinux.org/packages/r8125-dkms)を使うと楽だ。

デフォルトのビルド設定はかなり保守的になっていて、たとえばマルチキューなどの機能が有効化されていない。そのため、適宜書き換えてビルドする[^10]。

[^10]: OpenWrtでは[デフォルトでマルチキューが有効化されている](https://github.com/openwrt/openwrt/pull/18573)ため、それに倣った

```diff title="r8125-rss-dkms/PKGBUILD" lang="sh"
# （前略）
_pkgname=r8125
-pkgname=${_pkgname}-dkms
+pkgname=${_pkgname}-rss-dkms
pkgver=9.016.01
# （中略）
package() {
# （中略）
  sed -e "s/@_PKGNAME@/${_pkgname}/g" \
      -e "s/@PKGVER@/${pkgver}/g" \
      -i "${pkgdir}/usr/src/${dir_name}/dkms.conf"

+  sed -e 's/ENABLE_RSS_SUPPORT = n/ENABLE_RSS_SUPPORT = y/' \
+    -e 's/ENABLE_MULTIPLE_TX_QUEUE = n/ENABLE_MULTIPLE_TX_QUEUE = y/' \
+    -e 's/CONFIG_ASPM = y/CONFIG_ASPM = n/' \
+    -e 's/ENABLE_PAGE_REUSE = n/ENABLE_PAGE_REUSE = y/' \
+    -i "${pkgdir}/usr/src/${dir_name}/Makefile"
}
```

そして汎用ドライバを読み込まないようにする。

```txt
# /etc/modprobe.d/blacklist-r8169.conf

blacklist r8169
```

次回の起動時には`r8125`ドライバがロードされ、マルチキューが有効化されているはずだ。

```console {2}
> ethtool -i wan0
driver: r8125
version: 9.016.01-NAPI-RSS
firmware-version: 
expansion-rom-version: 
bus-info: 0000:03:00.0
supports-statistics: yes
supports-test: no
supports-eeprom-access: no
supports-register-dump: yes
supports-priv-flags: no
```

```console {9-10}
> ethtool -l wan0
Channel parameters for wan0:
Pre-set maximums:
RX:             4
TX:             2
Other:          n/a
Combined:       n/a
Current hardware settings:
RX:             3
TX:             2
Other:          n/a
Combined:       n/a
```

せっかく複数の送受信キューが使えるようになったので、irqbalanceでキューを各CPUコアに振り分けるようにしておく（おまじない）。

```sh
pacman -S irqbalance
systemctl enable --now irqbalance
```

ついでにNICの細かい設定もしておく。

```systemd
# /etc/systemd/network/01-wan0.link

[Match]
PermanentMACAddress=de:ad:be:ef:00:01

[Link]
Name=wan0
# MACアドレスのランダム化
MACAddressPolicy=random
```

```systemd
# /etc/systemd/network/01-lan0.link

[Match]
PermanentMACAddress=de:ad:be:ef:00:02

[Link]
Name=lan0
# Wake-On-LAN
WakeOnLan=magic
```

### カーネルパラメータのチューニング

[ArchWiki](https://wiki.archlinux.org/title/Sysctl)の教えに従い、TCP関連のさまざまなパラメータを調整する。

```ini title="/etc/sysctl.d/99-tuning.conf"
net.ipv4.tcp_slow_start_after_idle = 0
net.core.default_qdisc = cake
net.ipv4.tcp_congestion_control = bbr
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_mtu_probing = 1
net.ipv4.tcp_ecn = 1
```

もちろんルータとして使う以上、IPv4 / IPv6の転送設定は必須だ。

```ini title="/etc/sysctl.d/99-ip-forwarding.conf"
net.ipv4.ip_forward = 1
net.ipv4.conf.all.forwarding = 1
net.ipv6.conf.all.forwarding = 1
```

あとでIPv4 over IPv6トンネルを張る際に、不要なトンネルデバイス（`ip6tnl0`）が作成されないような設定もしておく。

```ini title="/etc/sysctl.d/99-no-fb-tunnel.conf"
net.core.fb_tunnels_only_for_init_net = 2
```

***

ここまでで一通りの環境構築が済んだ。[第二部](./bet-all-on-systemd-2)では端末をフレッツ網へ接続し、基本的なルータとしての機能を実現する。
